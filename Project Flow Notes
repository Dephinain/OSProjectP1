JOB FLOW:

Incoming job -> J_SCHED runs, determines what kind of job it is (IO, balanced, CPU), checks if any memory is available for it. If so, puts it onto the ready queue and allocates memory. If no memory available, shunted onto disk to await memory. Loads until ready queue memory is full, then calls J_DISPATCH. J_DISPATCH runs the job, then calls J_TERM to gather the statistics of the job and release the currently used memory for another process to use. J_SCHED is then run to handle an incoming job. J_SCHED then looks to the disk to see if anything on it fits the currently missing chunk of memory. It looks at each job's memory requirements, then if it fits, shunts it onto the ready queue. If not, the job gets punted to the end of the list to await its turn. If none of the jobs on disk fit the current memory profile, the incoming job is then checked and either shunted onto the ready queue or the disk depending. If both the disk AND ready queue are full, run J_DISPATCH and do the same thing until its ready. Keep in mind that there will be jobs that do not fit in any memory slot, and must be rejected before being stored to disk when mem_manager checks it.

Incoming job -> J_SCHED -> mem_manager check -> job to ready queue or disk -> if ready queue is full, run J_DISPATCH, which calls J_TERM when